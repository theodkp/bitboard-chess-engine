#include "uci.h"
#include "time.h"
#include "search.h"
#include "movegen.h"
#include "visual.h"
#include <stdio.h>
#include <string.h>

// UCI ***************************


// parse uci position

// parse move string input
int parse_move(const char* move_string){


    // init move list
    moves move_list[1];


    // generate moves
    generate_moves(move_list);

    // turn string format into int (a8 -> 0)
    int source = (move_string[0] - 'a')  + ( 8 - (move_string[1] - '0')) * 8;

    int target = (move_string[2] - 'a')  + ( 8 - (move_string[3] - '0')) * 8;

    for (int i = 0; i < move_list->count;i++){
        int move = move_list->moves[i];

        // make sure source & target squares are avaiable in moves generated by generate_moves function

        if (source == get_move_source(move) && target == get_move_target(move)){

            // handle promotion 
            int promoted = get_move_promoted(move);

            if(promoted){


                if ((promoted == Q || promoted == q) && move_string[4] == 'q'){
                    return move;
                }
                else if ((promoted == R || promoted == r) && move_string[4] == 'r'){
                    return move;
                }
                else if ((promoted == B || promoted == b) && move_string[4] == 'b'){
                    return move;
                }
                else if ((promoted == N || promoted == n) && move_string[4] == 'n'){
                    return move;
                }
                else{
                    continue;
                }

            }
            
            return move;
        }

        
    }

    // if by the end our move list loop we find no legal moves we return false
    return 0;


}




void parse_position(const char *command)
{
    command += 9;
    
    const char *current_char = command;
    
    // if startpos present in uci string we set to starting board position
    if (strncmp(command, "startpos", 8) == 0){
        parse_fen(start_position);
    }
        
    
    // if fen is entered 
    else{
        current_char = strstr(command, "fen");
        
        if (current_char == NULL){
            parse_fen(start_position);
            }
            
        else{
            // avoid whitespace to get to our actual fen string
            current_char += 4;
            
            // populate board with entered fen string
            parse_fen(current_char);
        }
    }
    
    /// if moves part of entered uci string continue making moves until done
    current_char = strstr(command, "moves");
    
    if (current_char != NULL){
        current_char += 6;
        
        while(*current_char){
            int move = parse_move(current_char);
            
            if (move == 0)
                break;
            
            repetition_index++;

            repetition_table[repetition_index] = hash_key;
            
            make_move(move, all_moves);
            
            while (*current_char && *current_char != ' ') current_char++;
            
            current_char++;
        }
        
       
    }
}



void parse_go(char* command)
{
	reset_time_control();

	int depth = -1;
	const char* argument;

	if ((argument = strstr(command, "infinite")))
	{
	}

	if ((argument = strstr(command, "binc")) && side == black)
	{
		increment = atoi(argument + 5);
	}
	if ((argument = strstr(command, "winc")) && side == white)
	{
		increment = atoi(argument + 5);
	}

	if ((argument = strstr(command, "wtime")) && side == white)
	{
		base_time = atoi(argument + 6);
	}

	if ((argument = strstr(command, "btime")) && side == black)
	{
		base_time = atoi(argument + 6);
	}

	if ((argument = strstr(command, "movestogo")))
	{
		moves_to_go = atoi(argument + 10);
	}

	if ((argument = strstr(command, "movetime")))
	{
		move_time = atoi(argument + 9);
	}

	if ((argument = strstr(command, "depth")))
	{
		depth = atoi(argument + 6);
	}

	if (move_time != -1)
	{
		base_time = move_time;
		moves_to_go = 1;
	}

	start_time = get_time_ms();

	if (base_time != -1)
	{
		is_time_set = 1;

		base_time /= moves_to_go;
		base_time -= 450;

		if (base_time < 0)
		{
			base_time = 0;
			increment -= 450;
			if (increment < 0)
			{
				increment = 1;
			}
		}

		stop_time = start_time + base_time + increment;
	}

	if (depth == -1)
	{
		depth = 64;
	}

    std::cout << "time:" << base_time 
              << " start:" << start_time 
              << " stop:" << stop_time 
              << " depth:" << depth 
              << " timeset:" << is_time_set 
              << std::endl;

	search_position(depth);
}



// main uci loop

void uci_loop()
{
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);
    
    char input[2000];
    
    std::cout<<"id name Bitboard chess engine\n";
    std::cout<<"id author bleuehour\n";
    
    std::cout<<"uciok\n";
    
    while (1){
        memset(input, 0, sizeof(input));
        
        fflush(stdout);
        
        if (!fgets(input, 2000, stdin)){
             continue;
        }
           
        
        if (input[0] == '\n'){
            continue;

        }
        
        // Uci ready
        if (strncmp(input, "isready", 7) == 0){
            std::cout<<"readyok\n";
            continue;
        }
        
        //  sets position
        else if (strncmp(input, "position", 8) == 0){
                parse_position(input);

                clear_hash_table();

        }
        
        // resets to new game
        else if (strncmp(input, "ucinewgame", 10) == 0){
            // clear hash table mem
            clear_hash_table();
            parse_position("position startpos");
        }
            
        // passes move into uci
        else if (strncmp(input, "go", 2) == 0){
            parse_go(input);
        }
           
        // exit out of uci loop
        else if (strncmp(input, "quit", 4) == 0){
            break;
        }
            
        
        else if (strncmp(input, "uci", 3) == 0){
            std::cout<<"id name Bitboard chess engine\n";
            std::cout<<"id author bleuehour\n";

            std::cout<<"uciok\n";
        }
    }
}